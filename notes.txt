An interface defines the interface of a generic type. A generic function says
"I accept types that implement this interface" so whenever you try to call a
function with a type, the compiler will check if the type satisfies the
interface. The compiler will also check if the function uses the interface
correctly. This might be easier to implement than C++ style generics.

interface Ordered {
  func lt(Self) -> bool;
};

func min<T: Ordered>(vals: [T]) -> T {
  if (size(vals) == 0u) {
    return make T {};
  }
  var elem = vals[0];
  for (i := 1u; i != size(vals); i++) {
    if (val[i].lt(elem)) {
      elem = val[i];
    }
  }
  return elem;
}

func swap<T>(a: ref T, b ref T) {
  let temp = a;
  a = b;
  b = temp;
}

In provide functions for working with arrays, we're going to need some kind
of generics.

func capacity<T>(arr: [T]) -> uint;
func size<T>(arr: [T]) -> uint;
func push_back<T>(arr: ref [T], elem: T);
func append<T>(arr: ref [T], other: [T]);
func pop_back<T>(arr: ref [T]);
func resize<T>(arr: ref [T], size: uint);
func reserve<T>(arr: ref [T], size: uint);

We don't need generic types (only generic functions) to deal with arrays.

--------------------------------------------------------------------------------

A closure is a pointer to a function and a reference counted pointer to captured
variables.

struct Closure {
  Function *func;
  retain_ptr<Data> data;
};

The reference counted pointer makes the closure a reference type.

A closure behaves very similarly to an entt::delegate except that the a pointer
to captured variables is stored instead of an instance pointer.

entt::delegate required wrapper functions but this implementation will not
require them.

Every function is actually a member function. So called "non-member functions"
accept a "this pointer" but simply ignore it. This means that a regular function
can be stored in a closure and it will ignore the nullptr to the captured data.
A capturing lambda function will accept the pointer to the captured data and
use it.

A closure is implemented in the same way that dynamic go-style interfaces
would be implemented except that the closure holds a single function pointer
where an interface would store a pointer to a table of function pointers that
make up the implementation of the interface. If we have one, do we really need
the other?

--------------------------------------------------------------------------------

think about the rules for function overloading and shadowing. Overload across modules?
should mutability be part of the type system properly? What we have now just lets use make variables constant
deal with user types void *
functional switch
use google test and maybe google benchmark
cache some stuff in the AST. Benchmark
consider using ORC
help optimizer with switch on global let
trivially relocatable optimizations

This is could be part of the standard library
func (self: sint) to_string() -> [char]








USE A STELA SCRIPT TO DEFINE A VECTOR SPRITE








organize the src directory (folder references instead of groups)
use memcmp when possible
optimize for trivially copyable structs that fit in registers
treat the return parameter as an lvalue (NRVO)
move construct closure captures when possible
maybe ast::Type uniquing?
maybe we shouldn't inline so aggressively
swap operator? :=:
expose reference counted pointers
arrays should be value types
cref

separate function signature from functions, lambdas and function types
  there are a lot of functions that only need to know the function signature
  but actually take sym::FuncParams or ast::Func.
  This is a mess!
consistent naming
  left -> lhs
  right -> rhs
  Type -> Ty

is ptr_union a good idea?
  we can remove a few dynamic casts
  malloc returns a pointer with alignment of std::max_align_t
